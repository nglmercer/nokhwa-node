/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Camera instance for capturing frames with full nokhwa functionality */
export declare class Camera {
  /**
   * Create a new camera instance with the given index
   * The camera stream is opened immediately with automatic format detection
   */
  constructor(cameraIndex: string)
  /**
   * Capture a single frame from the camera
   * Returns the frame as RGBA buffer with width and height
   */
  captureFrame(): Frame
  /** Get the camera index */
  index(): string
  /** Get the backend being used */
  backend(): ApiBackend
  /** Get camera information */
  info(): CameraDevice
  /**
   * Get the current camera format
   * Note: This returns the requested frame rate. Use refresh_camera_format()
   * to get the actual active frame rate from the camera.
   */
  cameraFormat(): CameraFormat
  /** Refresh and get the camera format */
  refreshCameraFormat(): CameraFormat
  /** Set camera format with requested configuration */
  setCameraRequest(request: RequestedFormatConfig): CameraFormat
  /** Get compatible camera formats */
  compatibleCameraFormats(): Array<CameraFormat>
  /** Get supported camera controls */
  supportedCameraControls(): Array<KnownCameraControl>
  /** Get all camera controls */
  cameraControls(): Array<CameraControl>
  /** Set a camera control value */
  setCameraControl(control: KnownCameraControl, value: ControlValueSetter): void
  /** Check if stream is open */
  isStreamOpen(): boolean
  /** Open the camera stream */
  openStream(): void
  /** Stop the camera stream */
  stopStream(): void
  /** Get raw frame data */
  frameRaw(): CameraBuffer
}

/** Buffer struct representing raw camera frame data */
export declare class CameraBuffer {
  /** Create a new buffer with resolution, data, and format */
  constructor(resolution: Resolution, data: Buffer, sourceFrameFormat: FrameFormat)
  /** Get the resolution of the buffer */
  resolution(): Resolution
  /** Get the raw buffer data */
  data(): Buffer
  /** Get the source frame format */
  sourceFrameFormat(): FrameFormat
  /** Get the width of the buffer */
  width(): number
  /** Get the height of the buffer */
  height(): number
  /** Get the size of the buffer in bytes */
  size(): number
  /** Check if the buffer is empty */
  isEmpty(): boolean
}

/** Get all known camera controls */
export declare function allKnownCameraControls(): Array<KnownCameraControl>

/** API backend options for camera access */
export declare const enum ApiBackend {
  Auto = 'Auto',
  MediaFoundation = 'MediaFoundation',
  AVFoundation = 'AVFoundation',
  OpenCv = 'OpenCv',
  Browser = 'Browser'
}

/** Convert BGR buffer to RGB */
export declare function bufBgrToRgb(width: number, height: number, bgr: Buffer): Buffer

/** Convert MJPEG buffer to RGB */
export declare function bufMjpegToRgb(width: number, height: number, mjpeg: Buffer): Buffer

/** Convert NV12 buffer to RGB */
export declare function bufNv12ToRgb(width: number, height: number, nv12: Buffer): Buffer

/** Convert YUYV422 buffer to RGB */
export declare function bufYuyv422ToRgb(width: number, height: number, yuyv: Buffer): Buffer

/** Camera control descriptor */
export interface CameraControl {
  name: string
  controlType: string
}

/** Camera device information */
export interface CameraDevice {
  index: string
  name: string
}

/** Camera format specification */
export interface CameraFormat {
  resolution: Resolution
  frameRate: number
  format: FrameFormat
}

/** Get all color frame formats */
export declare function colorFrameFormats(): Array<FrameFormat>

/** Control value types for setting camera properties */
export type ControlValueSetter =
  | { type: 'Integer', field0: number }
  | { type: 'Float', field0: number }
  | { type: 'Boolean', field0: boolean }
  | { type: 'String', field0: string }

/** Frame structure exported to JavaScript/TypeScript */
export interface Frame {
  data: Buffer
  width: number
  height: number
}

/** Frame format types supported by the camera */
export declare const enum FrameFormat {
  MJPEG = 'MJPEG',
  YUYV = 'YUYV',
  NV12 = 'NV12',
  RGB = 'RGB',
  RGBA = 'RGBA',
  GRAY = 'GRAY'
}

/** Get all available frame formats */
export declare function frameFormats(): Array<FrameFormat>

/** Known camera control properties */
export declare const enum KnownCameraControl {
  Brightness = 'Brightness',
  Contrast = 'Contrast',
  Saturation = 'Saturation',
  Hue = 'Hue',
  WhiteBalance = 'WhiteBalance',
  Gamma = 'Gamma',
  Sharpness = 'Sharpness',
  BacklightComp = 'BacklightComp',
  Gain = 'Gain',
  Pan = 'Pan',
  Tilt = 'Tilt',
  Zoom = 'Zoom',
  Exposure = 'Exposure',
  Iris = 'Iris',
  Focus = 'Focus',
  Other = 'Other'
}

/** List all available cameras */
export declare function listCameras(): Array<CameraDevice>

/** Convert MJPEG to RGB (convenience function) */
export declare function mjpegToRgb(mjpeg: Buffer, width: number, height: number): Buffer

/** Get native API backend */
export declare function nativeApiBackend(): ApiBackend | null

/** Check if nokhwa is initialized */
export declare function nokhwaCheck(): boolean

/** Convert NV12 to RGB (convenience function) */
export declare function nv12ToRgb(nv12: Buffer, width: number, height: number): Buffer

/** Query available cameras with specific backend */
export declare function query(backend: ApiBackend): Array<CameraDevice>

/** Requested format configuration */
export interface RequestedFormatConfig {
  requestType: RequestedFormatType
}

/** Format request types for automatic format selection */
export declare const enum RequestedFormatType {
  AbsoluteHighestResolution = 'AbsoluteHighestResolution',
  AbsoluteHighestFrameRate = 'AbsoluteHighestFrameRate'
}

/** Resolution dimensions */
export interface Resolution {
  width: number
  height: number
}

/** Get predicted size for YUYV422 format */
export declare function yuyv422PredictedSize(width: number, height: number): number

/** Convert YUYV422 to RGB (convenience function) */
export declare function yuyv422ToRgb(yuyv: Buffer, width: number, height: number): Buffer
